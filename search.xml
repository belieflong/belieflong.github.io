<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring入门简介]]></title>
    <url>%2F2017%2F05%2F06%2Fspring-intro%2F</url>
    <content type="text"><![CDATA[一、Spring的概念1.简介spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的： 目的：解决企业应用开发的复杂性 功能：使用基本的JavaBean代替EJB 范围：任何Java应用 2.起源Spring的存在是因为它自身有着得天独厚的优势： 它定位的领域是许多其他流行的framework没有的 Spring是全面的和模块化的 它的设计从底部帮助你编写易于测试的代码 Spring是潜在的一站式解决方案 3.优点Spring天生就存在如下的优点： 低侵入式设计，代码污染极低 Write Once, Run Anywhere DI有效的降低了耦合度 AOP提供了通用任务的集中管理 ORM和DAO简化了对数据库访问 高度开放性，并不强制 Spring的优点给开发带来的好处： 可以有效组织中间层对象 使用统一的配置文件 促进良好编程习惯，减少编程代价 易于单元测试 使EJB成为一种备选 为数据存取提供了一致的框架 4.特点方便解耦，简化开发 AOP编程的支持 声明式事务的支持 方便程序的测试 方便集成各种优秀框架 降低JavaEE API的使用难度 Spring的源码是经典学习范例 ###5.Spring的核心模块 核心容器(Spring Core) 应用上下文(Spring Context) AOP模块(Spring AOP) JDBC和DAO模块(Spring DAO) 对象实体映射（Spring ORM） Web模块(Spring Web) MVC模块(Spring Web MVC) 二、Spring之IOC1.浅谈IOCIOC（Inversion of Control，控制反转）是spring的核心，贯穿始终。 所谓IOC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系： 传统开发模式：对象之间互相依赖 IOC开发模式：IOC容器安排对象之间的依赖 2.依赖注入DIIOC的另外的名字叫做依赖注入（Dependency Injection），所谓的依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦 3.IOC的好处IOC在编程过程中不会对业务对象构成很强的侵入性，使用IOC之后，对象具有更好的可实行性，可重用性和可扩展性： 降低组件之间的耦合度 提高开发效率和产品质量 统一标准，提高模块的复用性 模块具有热插拔特性 4.IOC通俗的理解IOC控制反转：说的是创建对象实例的控制权从代码控制剥离到IOC容器控制，实际就是你在xml文件控制，侧重于原理 DI依赖注入：说的是创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现 三、Spring之AOP1.AOP的概念通俗理解：面向切面编程，AOP将应用系统分为两个部分：核心业务逻辑、横向的通用逻辑（即:方面：持久化管理、事务管理、安全管理、日志管理，调试管理等等） 在Spring当中提供了面向切面编程的丰富支持：允许通过分离应用的业务逻辑与系统及的服务，进行内聚性的开发，应用对象只实现他们应该做的，也就是完成 业务逻辑，并不负责其他关注点。 2.AOP和OOP的关系AOP是对OOP面向对象编程有意的补充，同时AOP也是OOP的延续 OOP：从静态角度考虑程序结构，即：OOP对业务处理过程的中的实体、以及属性和行为进行了抽象的封装，也或得更加清晰高效果的逻辑划分，研究的是静态的领域 AOP：从动态角度考虑程序运行过程，即：针对业务处理过程中的切面进行提取，它所面对的是处理中的某个步骤或者阶段，研究的是静态的领域 3.AOP的主要功能主要是用于系统级别的功能。例如：日志记录、性能统计、安全控制、事务处理、异常处理等等 4.AOP的主要意图把代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导性业务逻辑方法当中 进而改变这一行为的时候，不影响业务逻辑代码的处理。也就是说：AOP把一些常用的服务进行模块化，并且用声明的方式将这些组件使用到其他的业务组件中去，这样做的结果是，每一个业务组件，只需要关系自己的业务逻辑，而不用理解一些常用的业务组件，这样就保证了更高的内聚性。 使用AOP你可以将处理切面等代码注入程序，通常主程序的主要目的并不在于处理这些切面的功能，所以AOP可以有效的防止代码混乱 spring-framework的AOP作为一种轻型的AOP-framework，无需使用预编译器，或其他元标签，可以在JAVA程序中使用。 5.AOP的价值AOP 专门用于处理系统中分布于各个模块中的交叉关注点的问题，在 Java EE 应用中，常常通过 AOP 来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP 已经成为一种非常常用的解决方案 6.AOP的 原理剖析AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用，AOP 代理所包含的方法与目标对象的方法如下图所示： ●定义普通业务组件 ●定义切入点 ●定义增强处理 代理对象的方法 = 增强处理 + 被代理对象的方法 7.AOP的关键概念以下是官方文档所给出的AOP的关键概念的解释： 切面 - Aspect 连接点 - Join Point 通知 - Advice 切入点 - Point Cut 引入 - Introduction 目标对象 - Target Object AOP代理 - AOP Proxy 织入 - Weaving 8.AOP的通俗理解AOP通俗的理解：一个组件A，不关心其他常用的服务组件B，但是这个组件A使用组件B的时候，不是组件A自身去调用，而是通过配置等其他方式，比如Spring中可以通过xml配置文件。这样就使得A压根就不需要知道服务组件B是怎样的，爱存在不存在，爱怎么存在都与A无关。 A只关心自己的业务逻辑，具体A使用B的时候，配置文件去做，与具体的A组件无关。 四、Spring开发包介绍1.Spring的核心开发包的基本用途Spring Core：包含Spring框架的核心工具类，是其他组件的基本核心 Spring Beans：是所有应用都要用到的，它包含了访问配置文件、创建和管理Bean、以及进行控制反转、和依赖注入相关的所有类 Spring AOP：包含了使用Spring的AOP特性时所需要的类，利用这个jar文件，可以使用基于AOP的Spring特性。如：声明性的事务管理、日志系统的引入等等 Spring Context：为Spring的核心提供了大量的扩展，能够找到SpringAppliContexts特性时所需要的全部类、JNDI所需要的全部类、UI方面的用来和模版引擎,如：freemarker(用来生成输出文本的通用工具)、jasperreport(报表生成工具)集成的类,以及校验方面的相关类。 2.Spring的业务组件包（提供了各种企业级服务）Spring Aspects：提供了对了对AspectJ(面向切面的框架)的支持，以便可以方便的，将面向方面的功能集成进IDE中，比如：Eclipse、Ajdt(Eclipse基金的AspectJ是其中一个比较流行的AOP实现的插件)。 Spring Context Support：包含了支持缓存Cache、JCA(J2EE 连接器架构，是对J2EE标准集的重要补充)、JMX(Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架)、邮件服务、任务计划等方面的这些所有类。 Spring Expression：是Spring表达式语言，Spring3.0创建了一种新的方式，用以配置对象的注入，便是Spel (Spring Expression Language (SpEL))，支持在运行时操作和查询对象语法类似于 EL 语言，但是SpEL提供了额外的功能。 Spring Framework Bom：它是在使用 Maven (项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具)时,确保所有的Spring模块，都使用统一的版本。 Spring Instrument：提供Spring3.0对服务器的代理接口。 Spring Instrument Tomcat：提供了Spring3.0对Tomcat连接池的集成。 Spring JDBC：包含了Spring对JDBC数据访问时，进行封装的所有类，Spring提供了两种使用JDBC API的最佳时间， 1.以JdbcTemplate为核心的基于Template JDBC的使用方式 2.是在JdbcTemplate的基础之上构建的基于操作对象的Jdbc的使用方式。 Spring JMS：提供了对JMS 1.0和1.1的支持类，Spring的JMS抽象框架简化了JMS API的使用，并与JMS的提供者平滑的集成，org.springframework.jms.core包提供了在Spring中使用JMS的核心功能，它的模版类处理资源的创建和释放，简化了JMS的使用。 Spring ORM：Spring对DAO特性进行了扩展，使其支持iBatis、JDO、OJB、TopLink，因为hibernate已经独立承包，所以不包含在这个包里面了。这个JAR文件里大部分的类都需要依赖Spring-DAO.jar，所以使用这个包时，要包含进去。 Spring OXM：(Object-to-XML-Mapping的缩写)Spring对Object、XML的映射支持。可以让Java与Xml之间来回切换，是Spring3.0的一个新特性，OXM即是O/X-mapper，O/X映射器这个概念并不新鲜，O 代表 Object，X 代表 XML，它的目的是在Java对象和Xml文档之间相互转换。 Spring Struts：它提供了对Struts框架的支持，可以更方便更容易的集成Struts框架。 Spring test：它提供了对Junit等测试框架的简单封装，这让我们在对Spring的代码进行测试时更加方便和快捷。 Spring tx：即:Spring Transaction它为JDBC、Hibernate、JDO、JPA等提供的一致的声明式的编程式事务管理。 Spring web：包含Web应用研发时用到Spring框架时所需要的核心类，包括自动载入、WebApplicationContext特性的类、Struts和JFF集成类、文件上传的集成类、Filter类和大量辅组工具类。 Spring webmvc：包含了Spring mvc 框架的所有类，包括国际化、标签、视图展映的FreeMarker、jasperreport、Tiles、XSLT相关类，如果项目中使用了独立的MVC框架，则无需使用此类。 Spring webmvc portlet：提供了对Spring mvc的增强，支持了portlet标准]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows转ubuntu开发(一)]]></title>
    <url>%2F2017%2F05%2F06%2Flearn-ubuntu-devlop%2F</url>
    <content type="text"><![CDATA[###双系统安装(wind10 ubuntu16.04)工具：U盘、ubuntu16.01 镜像、UltraISO 具体操作：打开UltraISO-&gt;写入硬盘映像-&gt;选择好 Ubuntu 镜像和准备写入镜像的 U盘 写入方式：USB-ZIP+ 便捷启动：写入新的硬盘主引导记录 -&gt; USB-ZIP+ 重启选择U盘启动安装 选择与windows 共存 ###删除windows安装 清除整个磁盘并安装ubuntu ###搭建开发环境 Java、Android搭建(username为本地用户名) 1.下载jdk解压到指定目录。如：(/home/username/Develop/jdk1.8.0_111) 2.配置环境变量 (打开vim /etc/profile)追加以下内容(具体目录根据实际情况而定)1234export JAVA_HOME=/home/username/Develop/jdk1.8.0_111/export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin 3.执行(source /etc/profile)注销重新登录，让其生效(java -version)检查是否成功 4.安装Eclipse(解压到 /home/username/Develop/eclipse)，在eclipse目录执行 ./eclipse 启动eclipse 5.快捷创建图标(分别执行以下两条命令)12ln -s /home/username/Develop/eclipse/eclipse /usr/bin/eclipsevim /usr/share/applications/eclipse.desktop 将下面的代码粘贴到eclipse.desktop里12345678[Desktop Entry]Type=ApplicationName=eclipseComment=Eclipse Integrated Development EnvironmentExec=/usr/bin/eclipseIcon=/home/belieflong/Develop/eclipse/icon.xpmTerminal=falseCategories=Development;IDE;Java;Android; 6.搜索eclipse启动即可，并固定到启动器(所有快捷方式都可使用此步骤) 7.安装Android Sudio 8.下载解压Android Studio,进入android-studio/bin 目录,执行 ./sudio.sh 根据提示安装点击查看官方Android Studio安装教程 9.安装完成后配置追加Adnroid Studio环境变量，此时全部环境变量如下：123456export ANDROID_HOME=/home/username/Develop/Android/Sdk/export ANDROID_STUDIO=/home/username/Develop/android-studio/export JAVA_HOME=/home/username/Develop/jdk1.8.0_111/export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$ANDROID_STUDIO/bin:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools 10.再次执行(source /etc/profile)注销重新登录，让其生效(查看adb)是否成功 11.Android Studio 快捷方式同上。 JavaWeb环境工具：JavaEE、MyEclipse、Tomcat、mysql Tomcat： 官网下载Tomcat解压后进入bin目录 执行 ./startup.sh 开启 执行 ./shutdown.sh 关闭 未完待编写 mysql 首先卸载自带的 mysql-client-core-5.7 mariadb-client-core-10.0 未完待编写]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android随笔总结]]></title>
    <url>%2F2017%2F05%2F06%2Fanroid-essay%2F</url>
    <content type="text"><![CDATA[防止重复启动Activity1addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) Gson简单使用 Java对象转化Json数据12Gson gson = new Gson();gson.toJson(Object); Json数据转化Java对象 网络访问成功返回数据的方法 12345public void onResponse(String response) &#123; //成功获取网络json数据 Child2 child2 = gson.fromJson(response, Child2.class);&#125; List&lt;Child2&gt; child2List = gson.fromJson(response, new TypeToken&lt;List&lt;Child2&gt;&gt;()&#123;&#125;.getType()); 未完待更新]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型通配符之间的关系]]></title>
    <url>%2F2017%2F05%2F06%2Fjava-generic-type%2F</url>
    <content type="text"><![CDATA[1.继承关系123class Apple&#123;&#125;class Banana extend Apple&#123;&#125;class Orange extend Apple&#123;&#125; 2.泛型里面 A super B 表示A是B的父类或者祖先 A extend B 表示A是B的子类或者子孙 Java是单继承，所有继承的类构成一棵树。由于树这个结构上下是不对称的 参数写成：T&lt;? super B&gt;，对于这个泛型，?代表容器里的元素类型，由于只规定了元素必须是B的超类，导致元素没有明确统一的“根”（除了Object），所以这个泛型你其实无法使用它（除了把元素强制转成Object）。所以只能插入操作，而无法读 参数写成： T&lt;? extends B&gt;，由于指定了所有元素的“根”是B，你任何时候都可以安全的用B来使用容器里的元素，但是由于以B 为祖先的子树有很多，不同子树不兼容，所以禁止做插入操作，只做读取]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习总结(一)]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-learn-summary%2F</url>
    <content type="text"><![CDATA[Android系统架构 Linux内核层 Android 系统是基于Linux 内核的，这一层为Android设备的各种硬件提供了底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、WiFi驱动、电源管理等。 系统运行库层 这一层通过一些C/C++库来为Android系统提供了主要的特性支持。如SQLite、OpenGLES提供3D绘图的支持、Webkit提供了浏览器内核的支持等。 应用框架层 主要提供了构建应用程序时可能用到的各种API，Android 自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API开构建自己的应用程序。 应用层 所有安装在手机的应用程序都时属于这一层的。 Android四大组件使用Activity四大组件之一，主要用于和用户交互。 activity-&gt;布局-&gt;AndroidManifest注册 配置文件FirstActivity123456&lt;activity android:name=".FirstActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 显式Intent启动Activity123Intent intent = new Intent(FirstActivity.this,SecondActivity.class);....startActivityin(intent); 隐式Intent指定了一系列更为抽象的action和category等信息 配置文件SecondActivity12345678&lt;activity android:name=".SecondActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="com.example.activity.ACTION_START" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;指定多个category&gt; &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 通过指定action Category启动12345678910Intent intent = new Intent("com.example.activity.ACTION_START");intent.addCategory("指定多个category");....startActivityin(intent);更多用法：Intent intent = new Intent(Intent.ACTION_VIEW);intent.addData(Uri.parse("http://www.baidu.com"));Intent intent = new Intent(Intent.ACTION_DIAL);intent.addData(Uri.parse("tel:10086")); 标签还可以配置以下内容12345android:scheme。 用于指定数据的协议部分，如 http 部分android:host。 用于指定数据的主机部分，如 www.baidu.com 部分android:port。 用于指定数据的端口部分，一般紧随在主机名之后android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。 向下一个Activity传递数据传递值12345678//传递intent.putExtra("extra_data,"data"); ...putXXX();startActivity(intent);//获取Intent intent = getIntent();String data = intent.getStringExtra("extra_data"); //获取到dada...getXXX(); 返回数据给上一个Activity传递返回值123456789101112131415//启动前(第一个activity)startActivityForResult(intent,1);//重写方法(onActivityResult)switch(requestCode)&#123; case 1: if(resultCode == RESULT_OK)&#123; String returnedData = data.getStringExtra("data_return"); &#125; break;&#125;//启动后(返回事件)(第二个activity)intent.putExtra("data_return","Hello FirstActivity");setResult(RESULT_OK,intent);finish(); Activity的生命周期Activity状态 每个活动在其生命周期中最多可能会有4种状态 运行状态 位于返回栈的栈顶，这时Activity就处于运行状态。(低内存时系统不愿回收) 暂停状态 不在处于栈顶位置，但仍然看见时，这个Activity就进入了暂停状态。如：对对话框形式的Activity。(低内存时系统不愿回收) 停止状态 不在处于栈顶位置，并且完全不可见时，就进入了暂停状态。系统仍然会为这种Activity保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的活动可能会被系统回收。 销毁状态 Activity从返回栈中移除后就变成了销毁状态。 Activity的生存期Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节。 Activity跳转过程中的区分:AActivity -&gt; BActivity时(假设B全部遮挡住了A): A:onPause -&gt; B:onCreate -&gt; B:onStart -&gt; B:onResume -&gt; A:onStop 点击返回键时： B:onPause -&gt; A:onRestart -&gt; A:onStart -&gt; A:onResume -&gt; B:onStop -&gt; B:onDestroy。 目前Activity栈中只有A，在Android中有两个按键在影响Activity生命周期，即Back键和Home键。 如果按下Back键，系统返回到桌面，并依次执行A:onPause -&gt; A:onStop -&gt; A:onDestroy。 如果按下Home键（非长按），系统返回到桌面，并依次执行A:onPause -&gt; A:onStop。 由此可见，Back键和Home键主要区别在于是否会执行onDestroy。 Activity被回收]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission2%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission3%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission4%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission10%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission6%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission7%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission8%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission9%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission11%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission12%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行时权限处理]]></title>
    <url>%2F2017%2F05%2F06%2Fandroid-permission5%2F</url>
    <content type="text"><![CDATA[运行时权限的处理运行时判断并让用户选择12345if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this, new String[]&#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, 1);&#125;else &#123; openAlbum();&#125; 启动相册123456//选择照片private void openAlbum() &#123; Intent intent = new Intent("android.intent.action.GET_CONTENT"); intent.setType("image/*"); startActivityForResult(intent, CHOOSE_PHOTO);&#125; 权限请求结果1234567891011121314@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125;else &#123; Toast.makeText(this, "您已拒绝权限", Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android权限</tag>
      </tags>
  </entry>
</search>