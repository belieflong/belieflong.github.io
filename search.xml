<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OWT Server 环境搭建]]></title>
    <url>%2F2020%2F04%2F05%2Fowt-server-setup%2F</url>
    <content type="text"><![CDATA[下载源码下载指定的版本12wget https://github.com/open-webrtc-toolkit/owt-server/archive/v4.3.zip -O owt-server-4.3.zipunzip owt-server-4.3.zip 官方的仓库1git clone https://github.com/open-webrtc-toolkit/owt-server.git 安装依赖1cd owt-server &amp;&amp; ./scripts/installDepsUnattended.sh 编译native模块1./script/pack.js –t mcu –check 注意：GitHub上-t的参数是all，但如果服务器不支持硬件加速，会出错，所以在此我们使用mcu参数此命令会下载相关的依赖并编译 下载及编译app1git cline https://github.com/open-webrtc-toolkit/owt-client-javascript.git npm install grunt-cli -g 此步骤可以省略，安装依赖时已经安装上了若提示node不存在时，可以使用如下方式：nvm -v、nvm ls、nvm use node版本号1cd owt-client-javascript/scripts &amp;&amp; npm install &amp;&amp; grunt 如果想要生成debug的demo，则把grunt换成grunt debug，此时在dist目录下会生成sdk-debug目的。 打包1./scripts/pack.js -t all -f -a -s ~/owt-client-javascript-4.3/dist/samples/conference 运行的时候需要owt-client-javascript这个demo 配置 owt-server (在dist目录下)1、打开webrtc_agent/agent.toml目录，设置你服务器的公网IP，修改 [webrtc] 部分的 network_interfaces添加{name = “enp0s3”, replaced_ip_address = “本地ip地址”}2、编辑 portal/portal.toml：修改 [portal] 部分里的 ip_address 为服务器公网 IP 地址修改 ip_address = “本地ip地址” 初始化1cd owt-server/dist/ &amp;&amp; ./bin/init-all.sh 注意，此时会生成superID及superKey，后面登录console的时候需要使用到，并询问你是否初始化rabbitMQ及mongoDB，输入NO即可。如果点了YES，在后面启动模块的时候会报错（删除当前dist目录，再执行一次打包的步骤） 启动所有模块服务：12./bin/start-all.sh./bin/stop-all.sh 启动测试页面12https://localhost:3004https://localhost:3004/forward=true 验证后台服务console可以用来创建service及创建房间，输入(使用superId及superKey登录) https://localhost:3300/console 注意事项(1).下载时网络需要代理(2).执行init脚本时，选择No；登陆后台时，使用init生成的key登录(3).可以手动指定node（nvm use node版本号）或配置环境变量(4).修改server源码中的installCommonDeps.sh脚本，否则出现openssl-1.0.2下载失败的问题12将http://www.openssl.org/source/openssl-$&#123;SSL_VERSION&#125;.tar.gz修改为http://www.openssl.org/source/old/1.0.2/openssl-$&#123;SSL_VERSION&#125;.tar.gz可正常下载]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>owt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下断点调试webrtc android native层源码]]></title>
    <url>%2F2019%2F11%2F03%2Fwebrtc-android-native-debug%2F</url>
    <content type="text"><![CDATA[环境搭建ubuntu需要将webrtc android源码整体编译完成后进行1、拷贝webrtc/src/third_party下的Android SDK和NDK文件夹到某个目录2、配置环境变量123export ANDROID_HOME=~/android/android_sdkexport ANDROID_NDK_HOME=~/android/android_sdk/ndk-bundleexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_NDK_HOME 3、安装Android Studio（记得安装64位环境下的依赖库）下载官方的as安装包，以及安装依赖，并启动1sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 libbz2-1.0:i386 1cd android-studio/bin &amp;&amp; ./studio.sh 3、安装SDK相关工具Build Tools、Cmake、LLDB （可通过as的sdk管理界面安装）4、安装golang-go（编译报错 : go: not found）1sudo apt install golang-go 编译webrtc as工程代码1、下载webrtc android_gradle工程，将android_gradle工程放到源码/src/sdk目录下1https://github.com/HackWebRTC/webrtc/tree/hack_webrtc/sdk/android_gradle 2、修改gradle.properties中的相关路径问题。如：webrtc_repo、python、compile_native_code=true、protoc (/src/out/Debug/clang_x64/protoc) ，使用Android Studio打开 修改apprtc配置文件中版本号1、注释掉源码中src/examples/androidapp/AndroidManifest.xml中的版本号 执行sync碰到的报错问题as中执行sync时，生成相关文件路径为：/src/out/android_studio/gen根据实际报错内容进行解决，比如M77分支碰到的问题：1、找不到头文件：根据报错内容在源码中找到RefCounted.java文件，定位到void release() 方法，添加@CalledByNative2、注释掉webrtc.build中”–input_file sdk/android/api/org/webrtc/CandidatePairChangeEvent.java “文件等，input_file文件在源码中已经不存在了，所以要根据实际情况修改否则会报错。3、删除out/android_studio/gen重新sync；sync期间出现一个文件生成有问题，则接下来的文件也将无法生成 build期间报错问题出现该问题一般都是文件不存在或者路径问题，需要根据当前源代码1、检查/src/sdk/android_gradle/webrtc/third_party下报错模块的CMakeLists.txt里相关文件的路径是否正确2、例如：编译时报 src/sdk/android_gradle/webrtc/third_party/protobuf中找不到generated_enum_util.cc文件，则需要根据源码中 src/third_party对应模块中的xxx.gni文件所包含的源文件路径，对android_gradle工程下对应的CMakeLists.txt进行修改3、例如：M77分支修改了as工程中 libvpx、protobuf模块下的CMakeLists.txt 成功跑起来后就可以断点调试了]]></content>
      <categories>
        <category>WebRTC</category>
      </categories>
      <tags>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adb工具常用的命令]]></title>
    <url>%2F2018%2F12%2F04%2Fandroid-adb%2F</url>
    <content type="text"><![CDATA[启动和停止服务12adb start-serveradb kill-server 查看APK包名12aapt dump badging &lt;file_path.apk&gt; aapt工具在 android-sdk\build-tools对应的目录下 启动1am start -n 包名/.LauncherActicity //清单文件中配置的 安装以及卸载123adb install xxx.apkadb uninstall 包名adb shell pm uninstall -k 包名 保留用户数据 通过IP地址连接设备1adb connect ip地址 关闭连接12345adb disconnect``` ### 查看已经连接的设备``` shelladb devices 进入shell模式12adb shelladb -s 10.1.3.150 shell 指定具体设备 查看应用版本1adb shell dumpsys package com.examle.xx 输出安装包的APK路径1adb shell pm path &lt;PACKAGE&gt; 删除与包相关的所有数据：清除数据和缓存1adb shell pm clear &lt;PACKAGE&gt; 获取系统版本1adb shell getprop ro.build.version.release 获取系统api版本1adb shell getprop ro.build.version.sdk 获取相关制造商信息1adb shell getprop | grep "model\|version.sdk\|manufacturer\|hardware\|platform\|revision\|serialno\|product.name\|brand" 获取设备名称1cat /system/build.prop 推送文件到系统1adb push d:/key.xml /sdcard 拉取文件到当前目录1adb pull /sdcard . 查看内存1adb shell procrank 使文件系统可读写12345678adb shell mount -o remount,rw /systemadb remount或adb shell# mount 查看挂载找到挂载的名称/emmc@android /system ext4 rw,seclabel,relatime,noauto_da_alloc,commit=1,data=ordered 0 0# mount -o rw,remount -t ext4 /emmc@android system/ 写日志12345adb logcat -s TAG &gt; xx.log //指定TAG相关的日志写入文件adb logcat | grep PID &gt; xx.log //根据PID将日志写入文件adb logcat -c //清空日志adb logcat &gt; xx.log //开始文件通过Ctrl C 关掉即停止adb logcat -d &gt; xx.log //将缓存的日志输出到文件 帮助1adb logcat --help]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的三次握手与四次挥手过程，各个状态名称与含义]]></title>
    <url>%2F2018%2F05%2F14%2Ftcp-summary-handshake%2F</url>
    <content type="text"><![CDATA[转自 https://www.cnblogs.com/zedosu/p/6710167.html转自 https://blog.csdn.net/omnispace/article/details/52701752 三次握手第一次握手主机A发送位码为syn＝1,随机产生seq number=10001的数据包到服务器，主机B由SYN=1知道，A要求建立联机，此时状态为SYN_SENT； 第二次握手主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=20001的包，此时状态由LISTEN变为SYN_RECV； 第三次握手主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功，双方状态ESTABLISHED。完成三次握手，主机A与主机B开始传送数据 重点字段介绍序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下： URG：紧急指针（urgent pointer）有效。 ACK：确认序号有效。 PSH：接收方应该尽快将这个报文交给应用层。 RST：重置连接。 SYN：发起一个新连接。 FIN：释放一个连接。 需要注意的是 不要将确认序号Ack与标志位中的ACK搞混了。 确认方Ack=发起方Req+1，两端配对。 各个状态名称与含义CLOSED: 这个没什么好说的了，表示初始状态。LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。SYN_RECV: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。SYN_SENT: 这个状态与SYN_RECV遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状 态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。ESTABLISHED：这个容易理解了，表示连接已经建立了。 四次挥手 第一次挥手Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对 方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？ 这 是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未 必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文 和FIN报文多数情况下都是分开发送的。 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？ 因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态(就好比从SYN_SENT 状态到ESTABLISH 状态那样)，但是我们必须假想网络是不可靠的，你无法保证你(客户端)最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT 状态的作用就是用来重发可能丢失的ACK报文。 关闭TCP连接一定需要4次挥手吗? 不一定，4次挥手关闭TCP连接是最安全的做法。但在有些时候，我们不喜欢TIME_WAIT 状态(如当MSL数值设置过大导致服务器端有太多TIME_WAIT状态的TCP连接，减少这些条目数可以更快地关闭连接，为新连接释放更多资源)，这时我们可以通过设置SOCKET变量的SO_LINGER标志来避免SOCKET在close()之后进入TIME_WAIT状态，这时将通过发送RST强制终止TCP连接(取代正常的TCP四次握手的终止方式)。但这并不是一个很好的主意，TIME_WAIT 对于我们来说往往是有利的。 关于三次握手与四次挥手通常都会有典型的面试题，在此提出供有需求的XDJM们参考： 三次握手是什么或者流程？四次握手呢？答案前面分析就是。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg命令总结]]></title>
    <url>%2F2018%2F03%2F23%2Fffmpeg-command-summary%2F</url>
    <content type="text"><![CDATA[flv转换为mp4文件1ffmpeg -i wang_yi.flv -y -vcodec copy -acodec copy wang_yi_copy.mp4 ffmpeg如何控制profile&amp;level12345ffmpeg -i input.mp4 -profile:v baseline -level 3.0 output.mp4ffmpeg -i input.mp4 -profile:v main -level 4.2 output.mp4ffmpeg -i input.mp4 -profile:v high -level 5.1 output.mp4 设置输出视频的分辨率1ffmpeg -i input_file -vcodec h264 -s 1280x720 output_file flv转换为mp4文件12ffmpeg.exe -i source.mp4 -c:v libx264 -ar 22050 -crf 28 destinationfile.flvffmpeg.exe -i source.mp4 -c:v libx264 destination.flv -crf 控制转码后视频的质量，质量越高，文件也就越大。此值的范围是 0 到 51：0 表示高清无损；23 是默认值（如果没有指定此参数）；51 虽然文件最小，但效果是最差的。值越小，质量越高，但文件也越大，建议的值范围是 18 到 28。而值 18 是视觉上看起来无损或接近无损的，当然不代表是数据（技术上）的转码无损。-ar 采样率 设定声音采样率，PSP只认24000 提取YUV数据1ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv 提取PCM数据1ffmpeg -i input.mp4 -vn -ar 44100 -ac2 -f s16le out.pcm 播放pcm1ffplay input.pcm -f s16le -channels 2 -ar 44100 播放yuv1ffplay -f rawvideo -pixel_format yuv420p -s 640*360 file_640_360.yuv 按键小技巧12按w显示音频的波形图、左右键快进快退10s按s进入frame-step模式，按s键一次就会播放下一帧图像 列出电脑的设备1ffmpeg -list_devices true -f dshow -i dummy 测试摄像头1ffplay -f dshow -i video="HP HD Camera" //通过list_devices打印出来的名称 查询摄像头信息1ffmpeg -list_options true -f dshow -i video="HP HD Camera" 本地摄像头推流1ffmpeg -f dshow -i video="USB 视频设备" -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://xxx 本地推送文件指定编码格式1ffmpeg -re -stream_loop -1 -i file.flv -vcodec libx264 -acodec aac -f flv -y rtmp://xxx]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架之-入门简介]]></title>
    <url>%2F2017%2F05%2F06%2Fspring-intro%2F</url>
    <content type="text"><![CDATA[Spring的概念简介 spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的：目的：解决企业应用开发的复杂性功能：使用基本的JavaBean代替EJB范围：任何Java应用 起源 Spring的存在是因为它自身有着得天独厚的优势： 它定位的领域是许多其他流行的framework没有的 Spring是全面的和模块化的 它的设计从底部帮助你编写易于测试的代码 Spring是潜在的一站式解决方案 优点 Spring天生就存在如下的优点： 低侵入式设计，代码污染极低 Write Once, Run Anywhere DI有效的降低了耦合度 AOP提供了通用任务的集中管理 ORM和DAO简化了对数据库访问 高度开放性，并不强制 Spring的优点给开发带来的好处： 可以有效组织中间层对象 使用统一的配置文件 促进良好编程习惯，减少编程代价 易于单元测试 使EJB成为一种备选 为数据存取提供了一致的框架 特点 方便解耦，简化开发 AOP编程的支持 声明式事务的支持 方便程序的测试 方便集成各种优秀框架 降低JavaEE API的使用难度 Spring的源码是经典学习范例 Spring的核心模块 核心容器(Spring Core) 应用上下文(Spring Context) AOP模块(Spring AOP) JDBC和DAO模块(Spring DAO) 对象实体映射（Spring ORM） Web模块(Spring Web) MVC模块(Spring Web MVC) Spring之IOC浅谈IOC IOC（Inversion of Control，控制反转）是spring的核心，贯穿始终。所谓IOC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系：传统开发模式：对象之间互相依赖IOC开发模式：IOC容器安排对象之间的依赖 依赖注入DI IOC的另外的名字叫做依赖注入（Dependency Injection），所谓的依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦 IOC的好处 IOC在编程过程中不会对业务对象构成很强的侵入性，使用IOC之后，对象具有更好的可实行性，可重用性和可扩展性： 降低组件之间的耦合度 提高开发效率和产品质量 统一标准，提高模块的复用性 模块具有热插拔特性 IOC通俗的理解 IOC控制反转：说的是创建对象实例的控制权从代码控制剥离到IOC容器控制，实际就是你在xml文件控制，侧重于原理DI依赖注入：说的是创建对象实例时，为这个对象注入属性值或其它对象实例，侧重于实现 Spring之AOPAOP的概念 通俗理解：面向切面编程，AOP将应用系统分为两个部分：核心业务逻辑、横向的通用逻辑（即:方面：持久化管理、事务管理、安全管理、日志管理，调试管理等等）在Spring当中提供了面向切面编程的丰富支持：允许通过分离应用的业务逻辑与系统及的服务，进行内聚性的开发，应用对象只实现他们应该做的，也就是完成业务逻辑，并不负责其他关注点。 AOP和OOP的关系 AOP是对OOP面向对象编程有意的补充，同时AOP也是OOP的延续OOP：从静态角度考虑程序结构，即：OOP对业务处理过程的中的实体、以及属性和行为进行了抽象的封装，也或得更加清晰高效果的逻辑划分，研究的是静态的领域AOP：从动态角度考虑程序运行过程，即：针对业务处理过程中的切面进行提取，它所面对的是处理中的某个步骤或者阶段，研究的是静态的领域 AOP的主要功能 主要是用于系统级别的功能。例如：日志记录、性能统计、安全控制、事务处理、异常处理等等 AOP的主要意图 把代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导性业务逻辑方法当中，进而改变这一行为的时候，不影响业务逻辑代码的处理。也就是说：AOP把一些常用的服务进行模块化，并且用声明的方式将这些组件使用到其他的业务组件中去，这样做的结果是，每一个业务组件，只需要关系自己的业务逻辑，而不用理解一些常用的业务组件，这样就保证了更高的内聚性。 使用AOP你可以将处理切面等代码注入程序，通常主程序的主要目的并不在于处理这些切面的功能，所以AOP可以有效的防止代码混乱。 spring-framework的AOP作为一种轻型的AOP-framework，无需使用预编译器，或其他元标签，可以在JAVA程序中使用。 AOP的价值 AOP 专门用于处理系统中分布于各个模块中的交叉关注点的问题，在 Java EE 应用中，常常通过 AOP 来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP 已经成为一种非常常用的解决方案 AOP的 原理剖析 AOP 代理其实是由 AOP 框架动态生成的一个对象，该对象可作为目标对象使用，AOP 代理所包含的方法与目标对象的方法如下图所示： 定义普通业务组件 定义切入点 定义增强处理 代理对象的方法 = 增强处理 + 被代理对象的方法 AOP的关键概念 以下是官方文档所给出的AOP的关键概念的解释：切面 - Aspect连接点 - Join Point通知 - Advice切入点 - Point Cut引入 - Introduction目标对象 - Target ObjectAOP代理 - AOP Proxy织入 - Weaving AOP的通俗理解 AOP通俗的理解：一个组件A，不关心其他常用的服务组件B，但是这个组件A使用组件B的时候，不是组件A自身去调用，而是通过配置等其他方式，比如Spring中可以通过xml配置文件。这样就使得A压根就不需要知道服务组件B是怎样的，爱存在不存在，爱怎么存在都与A无关。A只关心自己的业务逻辑，具体A使用B的时候，配置文件去做，与具体的A组件无关。 Spring开发包介绍Spring的核心开发包的基本用途 Spring Core：包含Spring框架的核心工具类，是其他组件的基本核心Spring Beans：是所有应用都要用到的，它包含了访问配置文件、创建和管理Bean、以及进行控制反转、和依赖注入相关的所有类Spring AOP：包含了使用Spring的AOP特性时所需要的类，利用这个jar文件，可以使用基于AOP的Spring特性。如：声明性的事务管理、日志系统的引入等等Spring Context：为Spring的核心提供了大量的扩展，能够找到SpringAppliContexts特性时所需要的全部类、JNDI所需要的全部类、UI方面的用来和模版引擎,如：freemarker(用来生成输出文本的通用工具)、jasperreport(报表生成工具)集成的类,以及校验方面的相关类。 Spring的业务组件包（提供了各种企业级服务） Spring Aspects：提供了对了对AspectJ(面向切面的框架)的支持，以便可以方便的，将面向方面的功能集成进IDE中，比如：Eclipse、Ajdt(Eclipse基金的AspectJ是其中一个比较流行的AOP实现的插件)。Spring Context Support：包含了支持缓存Cache、JCA(J2EE 连接器架构，是对J2EE标准集的重要补充)、JMX(Java管理扩展）是一个为应用程序、设备、系统等植入管理功能的框架)、邮件服务、任务计划等方面的这些所有类。Spring Expression：是Spring表达式语言，Spring3.0创建了一种新的方式，用以配置对象的注入，便是Spel (Spring Expression Language (SpEL))，支持在运行时操作和查询对象语法类似于 EL 语言，但是SpEL提供了额外的功能。Spring Framework Bom：它是在使用 Maven (项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具)时,确保所有的Spring模块，都使用统一的版本。Spring Instrument：提供Spring3.0对服务器的代理接口。Spring Instrument Tomcat：提供了Spring3.0对Tomcat连接池的集成。Spring JDBC：包含了Spring对JDBC数据访问时，进行封装的所有类，Spring提供了两种使用JDBC API的最佳时间： 以JdbcTemplate为核心的基于Template JDBC的使用方式 是在JdbcTemplate的基础之上构建的基于操作对象的Jdbc的使用方式。 Spring JMS：提供了对JMS 1.0和1.1的支持类，Spring的JMS抽象框架简化了JMS API的使用，并与JMS的提供者平滑的集成，org.springframework.jms.core包提供了在Spring中使用JMS的核心功能，它的模版类处理资源的创建和释放，简化了JMS的使用。Spring ORM：Spring对DAO特性进行了扩展，使其支持iBatis、JDO、OJB、TopLink，因为hibernate已经独立承包，所以不包含在这个包里面了。这个JAR文件里大部分的类都需要依赖Spring-DAO.jar，所以使用这个包时，要包含进去。Spring OXM：(Object-to-XML-Mapping的缩写)Spring对Object、XML的映射支持。可以让Java与Xml之间来回切换，是Spring3.0的一个新特性，OXM即是O/X-mapper，O/X映射器这个概念并不新鲜，O 代表 Object，X 代表 XML，它的目的是在Java对象和Xml文档之间相互转换。Spring Struts：它提供了对Struts框架的支持，可以更方便更容易的集成Struts框架。Spring test：它提供了对Junit等测试框架的简单封装，这让我们在对Spring的代码进行测试时更加方便和快捷。Spring tx：即:Spring Transaction它为JDBC、Hibernate、JDO、JPA等提供的一致的声明式的编程式事务管理。Spring web：包含Web应用研发时用到Spring框架时所需要的核心类，包括自动载入、WebApplicationContext特性的类、Struts和JFF集成类、文件上传的集成类、Filter类和大量辅组工具类。Spring webmvc：包含了Spring mvc 框架的所有类，包括国际化、标签、视图展映的FreeMarker、jasperreport、Tiles、XSLT相关类，如果项目中使用了独立的MVC框架，则无需使用此类。Spring webmvc portlet：提供了对Spring mvc的增强，支持了portlet标准]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
</search>
